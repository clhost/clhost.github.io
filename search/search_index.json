{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<ul> <li> <p> Articles</p> <p>Own experience as a Software Engineer</p> <p> Read articles</p> </li> <li> <p> Projects</p> <p>All about my personal projects</p> <p> Take a look</p> </li> <li> <p> Algorithms</p> <p>Own notes for algorithms</p> <p> Learn something new</p> </li> </ul>"},{"location":"algorithms/","title":"Algorithms","text":"<p>I put all my notes for algorithms here.</p> <p>I use Kotlin so all examples here can be found in Kotlin.</p>"},{"location":"algorithms/cases/hash-map/","title":"Hash map","text":""},{"location":"algorithms/datastructures/monotonic-stack/","title":"Monotonic stack","text":""},{"location":"algorithms/datastructures/monotonic-stack/#tips","title":"Tips","text":"<ol> <li>If we encounter keywords <code>subarray</code> and <code>minimum / maximum</code> -&gt; use a monotonic stack</li> <li>Try dividing the task into several smaller ones and apply the third tip</li> <li>For every task where a monotonic stack can be used, start your reasoning with a phrase  let's do something for each element</li> </ol>"},{"location":"algorithms/datastructures/monotonic-stack/#how-to-use-a-monotonic-stack-to-find-ranges-for-an-element","title":"How to use a monotonic stack to find ranges for an element","text":"<p>Hard  1063. Number of Valid Subarrays</p> <p>Medium  907. Sum of Subarray Minimums</p> <p>Medium  2104. Sum of Subarray Ranges</p> <p>It's pretty simple to use a <code>monotonic stack</code> to find ranges.</p> <p>For example, we have an array like <code>[8, 6, 3, 5, 4, 9, 2]</code>.</p> <p>How to determine the range in which an element is minimum?</p> <p>For example, for the element <code>4</code> it's <code>(3, 5, 4, 9, 2)</code>.</p> <p>The solution is:</p> <pre><code>// let's assume that we have an array \"arr\" of integer numbers\n// let's assume that we have a stack that is created through LinkedList&lt;Int&gt;()\nfor (i in 0 .. arr.size) {\nwhile (!stack.isEmpty() &amp;&amp; (i == arr.size || arr[stack.peek()] &gt;= arr[i])) {\nval middle = stack.pop()\nval left = if (stack.isEmpty()) -1 else stack.peek()\nval right = i\nval count = (middle - left) * (right - middle) // here we count the number of ranges\n}\nstack.push(i)\n}\n</code></pre> <p>So let's iterate through <code>[8, 6, 3, 5, 4, 9, 2]</code>: <pre><code>i = 0, stack = []\ni = 1, stack = [8]\ni = 2, stack = [6], because 8 &gt; 6 and here we find out a range for 8 (-1, 8, 6)\ni = 3, stack = [3], because 6 &gt; 3 and here we find out a range for 6 (-1, 6, 3)\ni = 4, stack = [3, 5]\ni = 5, stack = [3, 4], because 5 &gt; 4 and here we find out a range for 5 (3, 5, 4)\ni = 6, stack = [3, 4, 9]\ni = 7, stack = [2], because 3, 4, 9 &gt; 2 and here:\n\nwe find out a range for 9 (4, 9, 2)\nwe find out a range for 4 (3, .., 4, .., 2)\nwe find out a range for 3 (-1, 3, .., 2)\nwe find out a range for 2 (-1, 2, -1)\n</code></pre></p>"},{"location":"algorithms/frameworks/backtracking/","title":"Backtracking","text":""},{"location":"algorithms/frameworks/backtracking/#how-to-avoid-duplicates-working-with-backtracking","title":"How to avoid duplicates working with backtracking","text":"<p>Medium  90. Subsets II</p> <p>Medium  40. Combination Sum II</p> <p>One of the basic ideas for avoiding duplication involves sorting.</p> <p>For example, we are given an array <code>candidates = [10,1,2,7,6,1,5]</code> and a <code>target = 8</code>.</p> <p>How to find all unique combinations in candidates where the candidate numbers sum to target?</p> <p>In here we have to avoid duplicates, for example, if we found <code>[1,2,5]</code> we have to avoid <code>[2,1,5]</code>.</p> <p>The solution is:</p> <pre><code>// sort an array\n// inside the loop of the backtracking recursive function\nif (i != start &amp;&amp; array[i] == array[start]) {\ncontinue\n}\n</code></pre>"},{"location":"blog/","title":"Posts","text":""},{"location":"blog/2023/08/30/first-post/","title":"First post","text":"<p>This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. </p>"},{"location":"blog/2023/08/30/second-post/","title":"Second post","text":"<p>This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. This is a long text. </p>"},{"location":"projects/","title":"Projects","text":""},{"location":"blog/category/architecture/","title":"Architecture","text":""},{"location":"blog/category/leetcode/","title":"Leetcode","text":""}]}